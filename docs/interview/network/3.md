# http2.0、http3.0、https
## 一、http2.0
### 概念
HTTP/2 是HTTP协议的第二个主要版本，主要基于`SPDY协议`。HTTP2.0的特点是：在不改动HTTP语义、方法、状态码、URI及首部字段的情况下，大幅度提高了web性能。
### 什么是SPDY协议
`SPDY协议`是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数。
### HTTP1.x的缺点
* HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。
* 单向请求，只能由客户端发起。
* 请求报文与响应报文首部信息冗余量大。
* 数据未压缩，导致数据的传输量大。

我们可以通过一个链接来对比一下HTTP2.0到底比HTTP1.x快了多少。

![image](https://pic4.zhimg.com/v2-4941fe9fd2f9eadcdc47932598c420e3_b.webp)
### HTTP2.0的优点
#### （1）二进制传输
HTTP2.0中所有加强性能的核心是二进制传输，在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。
在HTTP2.0中引入了二进制格式编码机制，所有传输的数据都会被分割，并采用二进制格式编码。
![image](https://image-static.segmentfault.com/255/492/2554926774-5b8e41d288514_articlex)

为了保证HTTP不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。
#### （2）多路复用
在HTTP1.0中，我们经常会使用到雪碧图、使用多个域名等方式来进行优化，都是因为浏览器限制了同一个域名下的请求数量，当页面需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求时，资源需要等待其他资源请求完成后才能继续发送。
HTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。
帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。
所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的标识知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。

![image](https://image-static.segmentfault.com/145/296/1452964433-5b8e41d284282_articlex)

多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。
#### （3）Header压缩
在HTTP1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。
在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。

#### （4）服务器Push
在HTTP2.0中，服务端可以在客户端某个请求后，主动推送其他资源。
可以想象一下，某些资源客户端是一定会请求的，这时就可以采取服务端push的技术，提前给客户端推送必要的资源，就可以相对减少一点延迟时间。在浏览器兼容的情况下也可以使用prefetch。

#### （5）更安全
HTTP2.0使用了tls的拓展ALPN做为协议升级，除此之外，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。

## 二、http3.0
HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。因为在出现丢包的情况下，整个TCP都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1来说，可以开启多个TCP连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。

基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上，QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。
### 多路复用
虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。

并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。
### 0-RTT
通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。
### 纠错机制
假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。

当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。
## 三、https
HTTPS在传统的HTTP和TCP之间加了一层用于加密解密的SSL/TLS层。使用HTTPS必须要有一套自己的数字证书（包含公钥和私钥）。

HTTPS解决的问题
* 信息加密传输：第三方无法窃听
* 完整性校验：一旦被篡改，通信双方会立刻发现
* 身份认证：防止身份被冒充

HTTPS加密过程：

![image](/blog/images/https.png)

**加密过程使用了对称加密和非对称加密。在交换密钥阶段使用非对称加密方式，之后建立通信交换报文阶段则使用对称加密。**
### 非对称加密
客户端通过公钥加密。服务端通过私钥解密.

非对称加密密使用一对非对称的密钥。一把叫做公钥，一把叫做私钥。私钥不能让其他任何人知道，而公钥则可以随意发布，任何人都可以获得。使用此加密方式，发送密文的一方使用公钥进行加密处理，对方收到被加密的信息后，再使用自己的私钥进行解密。利用这种方式，不需要发送用来解密的私钥，也不必担心密钥被攻击者窃听盗走。
```js
    encrypt(明文，公钥) = 密文
    decrypt(密文，私钥) = 明文
```
由于非对称加密比对称加密要慢，所以我们就需要综合一下他们两者的优缺点，使他们共同使用，而这也是HTTPS采用的加密方式。
### 对称加密
客户端和服务端采用相同的密钥经行加密。
```js
    encrypt(明文，密钥) = 密文
    decrypt(密文，密钥) = 明文
```
### HTTPS 握手过程中，客户端如何验证证书的合法性
* 校验证书的颁发机构是否受客户端信任。
* 通过 CRL 或 OCSP 的方式校验证书是否被吊销。
* 对比系统时间，校验证书是否在有效期内。
* 通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致。