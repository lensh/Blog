# Vue源码解读（二）
## 一、Vue虚拟DOM
虚拟DOM（Virtual DOM）是对DOM的JS抽象表示，它们是JS对象，能够描述DOM结构和关系。应用的各种状态变化会先作用于虚拟DOM，最终映射到DOM上。

![iamge](/blog/images/3.png)

::: tip 虚拟DOM优点
虚拟DOM轻量、快速，当它们发生变化时通过新旧虚拟DOM比对可以得到最小DOM操作量，从而提升性能和用户体验。本质上是使用JavaScript运算成本替换DOM操作的执行成本，前者运算速度要比后者快得多，这样做很划算，因此才会有虚拟DOM。

vue 1.0中有细粒度的数据变化侦测，它是不需要虚拟DOM的，但是细粒度造成了大量开销，这对于大型项目来说是不可接受的。因此，vue 2.0选择了中等粒度的解决方案，每一个组件对应一个watcher实例， 这样状态变化时只能通知到组件，再通过引入虚拟DOM去进行比对和渲染。

但是有一点需要注意，虽然每一个组件对应一个watcher实例，但是组件的数量和watcher实例的数量不一定是相等的，因为组件内可能还会有用户手动创建的watcher，比如$watch或者watch方法创建的watcher。
:::
### VNode
VNode，就是虚拟DOM，定义在`src\core\vdom\vnode.js`
```js
// VNode对象，共有6种类型：元素、组件、文本、函数式组件、注释和克隆节点
export default class VNode {
  tag: string | void; // 节点标签，文本和注释没有
  data: VNodeData | void; // 节点数据
  children: ?Array<VNode>;  // 元素的子元素
  text: string | void;  // 文本、注释的内容
  elm: Node | void;
  ns: string | void;
  context: Component | void; // rendered in this component's scope
  functionalContext: Component | void; // only for functional component root nodes
  key: string | number | void;
  componentOptions: VNodeComponentOptions | void;
  componentInstance: Component | void; // component instance
  parent: VNode | void; // component placeholder node
  raw: boolean; // contains raw HTML? (server only)
  isStatic: boolean; // hoisted static node
  isRootInsert: boolean; // necessary for enter transition check
  isComment: boolean; // empty comment placeholder?
  isCloned: boolean; // is a cloned node?
  isOnce: boolean; // is a v-once node?

  constructor (
    tag?: string,
    data?: VNodeData,
    children?: ?Array<VNode>,
    text?: string,
    elm?: Node,
    context?: Component,
    componentOptions?: VNodeComponentOptions
  ) {
    /*当前节点的标签名*/
    this.tag = tag
    /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/
    this.data = data
    /*当前节点的子节点，是一个数组*/
    this.children = children
    /*当前节点的文本*/
    this.text = text
    /*当前虚拟节点对应的真实dom节点*/
    this.elm = elm
    /*当前节点的名字空间*/
    this.ns = undefined
    /*编译作用域*/
    this.context = context
    /*函数化组件作用域*/
    this.functionalContext = undefined
    /*节点的key属性，被当作节点的标志，用以优化*/
    this.key = data && data.key
    /*组件的option选项*/
    this.componentOptions = componentOptions
    /*当前节点对应的组件的实例*/
    this.componentInstance = undefined
    /*当前节点的父节点*/
    this.parent = undefined
    /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/
    this.raw = false
    /*静态节点标志*/
    this.isStatic = false
    /*是否作为根节点插入*/
    this.isRootInsert = true
    /*是否为注释节点*/
    this.isComment = false
    /*是否为克隆节点*/
    this.isCloned = false
    /*是否有v-once指令*/
    this.isOnce = false
  }

  get child (): Component | void {
    return this.componentInstance
  }
}
```
这是一个最基础的VNode节点，作为其他派生VNode类的基类，里面定义了下面这些数据。
::: tip 
tag: 当前节点的标签名

data: 当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息

children: 当前节点的子节点，是一个数组

text: 当前节点的文本

elm: 当前虚拟节点对应的真实dom节点

ns: 当前节点的名字空间

context: 当前节点的编译作用域

functionalContext: 函数化组件作用域

key: 节点的key属性，被当作节点的标志，用以优化

componentOptions: 组件的option选项

componentInstance: 当前节点对应的组件的实例

parent: 当前节点的父节点

raw: 简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false

isStatic: 是否为静态节点

isRootInsert: 是否作为跟节点插入

isComment: 是否为注释节点

isCloned: 是否为克隆节点

isOnce: 是否有v-once指令
:::
---
打个比方，比如说我现在有这么一个VNode树
```JavaScript
{
    tag: 'div'
    data: {
        class: 'test'
    },
    children: [
        {
            tag: 'span',
            data: {
                class: 'demo'
            }
            text: 'hello,VNode'
        }
    ]
}
```
渲染之后的结果就是这样的
```html
<div class="test">
    <span class="demo">hello,VNode</span>
</div>
```
### mountComponent
vdom树首页生成、渲染发生在mountComponent中，`src\core\instance\lifecycle.js`，核心代码如下
```js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el  // 挂载的宿主元素
  callHook(vm, 'beforeMount') // 调用beforeMount钩子
  
  // 定义更新函数updateComponent，实际调用vm._update
  let updateComponent = () => {
      // vm._update是更新函数，内部会做diff算法，vm._render()是渲染函数，渲染函数返回虚拟DOM
      vm._update(vm._render(), hydrating)
  }

  // 实例化watcher，并传入更新函数
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```
从源码可知，实例化watcher时传入了更新函数updateComponent，updateComponent实际调用了`vm._update`，vm._update是更新函数，内部会做diff算法，`vm._render()`是渲染函数，渲染函数返回虚拟DOM。所以接下来我们要去研究`vm._render`和`vm._update`。
### vm._render
_render生成虚拟dom，`src\core\instance\render.js`，核心代码如下
```js
Vue.prototype._render = function (): VNode {
    const vm: Component = this
    const { render, _parentVnode } = vm.$options  // 从$options里拿出render函数

    vm.$vnode = _parentVnode
    // 调用render方法生成虚拟DOM
    let vnode = render.call(vm._renderProxy, vm.$createElement)
    return vnode
}
```
### vm._update
vm._update 是更新函数，内部会做虚拟DOM的diff算法，`src\core\instance\lifecycle.js`，核心代码如下
```js
  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    const prevEl = vm.$el // 拿到DOM元素
    const prevVnode = vm._vnode // 老的Vnode
    const restoreActiveInstance = setActiveInstance(vm)
    vm._vnode = vnode
    
    // 打补丁利用vm.__patch__
    if (!prevVnode) {
      // 如果没有老的Vnode，则将DOM元素和虚拟DOM传入，进行初始化渲染
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // 否则比较新旧虚拟DOM，得出最小差异，然后操作DOM
      vm.$el = vm.__patch__(prevVnode, vnode)
    }
    restoreActiveInstance()
    // 更新vue实例的引用__vue__
    if (prevEl) {
      prevEl.__vue__ = null
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm
    }
  }

  Vue.prototype.$forceUpdate = function () {
    const vm: Component = this
    if (vm._watcher) {  // 强制更新
      vm._watcher.update()
    }
  }
```
从源码可知，_update负责更新dom，核心是调用`__patch__`，所以接下来我们要去研究`__patch__ `。
### vm.__patch__和patch
`__patch__`是在平台特有代码中指定的， `src\platforms\web\runtime\index.js`.
```js
import { patch } from './patch'  // 引入了patch.js里的patch方法

Vue.prototype.__patch__ = inBrowser ? patch : noop
```
patch方法的定义在 `src\platforms\web\runtime\patch.js`，核心代码如下
```js
import * as nodeOps from 'web/runtime/node-ops' // 定义各种原生dom基础操作方法
import { createPatchFunction } from 'core/vdom/patch'
import baseModules from 'core/vdom/modules/index'
import platformModules from 'web/runtime/modules/index'

const modules = platformModules.concat(baseModules)

export const patch: Function = createPatchFunction({ nodeOps, modules })
```
**可见 patch 实际就是`createPatchFunction`的返回值，需要传递`nodeOps`和`modules`，这里主要是为了跨平台。**
### nodeOps和modules
nodeOps定义了各种原生dom基础操作方法，nodeOps定义在`src\platforms\web\runtime\node-ops.js`
```js
import { namespaceMap } from 'web/util/index'

export function createElement (tagName: string, vnode: VNode): Element {
  const elm = document.createElement(tagName)
  if (tagName !== 'select') {
    return elm
  }
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple')
  }
  return elm
}

export function createElementNS (namespace: string, tagName: string): Element {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

export function createTextNode (text: string): Text {
  return document.createTextNode(text)
}

export function createComment (text: string): Comment {
  return document.createComment(text)
}

export function insertBefore (parentNode: Node, newNode: Node, referenceNode: Node) {
  parentNode.insertBefore(newNode, referenceNode)
}

export function removeChild (node: Node, child: Node) {
  node.removeChild(child)
}

export function appendChild (node: Node, child: Node) {
  node.appendChild(child)
}

export function parentNode (node: Node): ?Node {
  return node.parentNode
}

export function nextSibling (node: Node): ?Node {
  return node.nextSibling
}

export function tagName (node: Element): string {
  return node.tagName
}

export function setTextContent (node: Node, text: string) {
  node.textContent = text
}

export function setStyleScope (node: Element, scopeId: string) {
  node.setAttribute(scopeId, '')
}
```
modules 定义了虚拟dom更新 => dom操作转换的方法，比如attr、class、events、style、transition等的转换方法。定义在`src\platforms\web\runtime\modules\index.js`，

拿attr更新来说，具体更新方法定义在`src\platforms\web\runtime\modules\attrs.js`，核心代码如下
```js
function updateAttrs (oldVnode: VNodeWithData, vnode: VNodeWithData) {
  let key, cur, old
  const elm = vnode.elm 
  const oldAttrs = oldVnode.data.attrs || {} // 老的属性
  let attrs: any = vnode.data.attrs || {}  // 新的属性

  // 遍历新的属性，如果老的属性值和新的属性值不等，则更新属性值
  for (key in attrs) {
    cur = attrs[key]
    old = oldAttrs[key]
    if (old !== cur) {
      setAttr(elm, key, cur)  // 更新属性值
    }
  }
  // 遍历旧的属性
  for (key in oldAttrs) {
    // 如果新的属性的属性值没有定义，则把这个属性删除
    if (isUndef(attrs[key])) {
        elm.removeAttribute(key)
    }
  }
}
```
### createPatchFunction
createPatchFunction，创建并返回patch方法，需要传入nodeOps和modules，该方法定义在`src\core\vdom\patch.js`里面，patch方法才是真正的打补丁的方法。下面小节剖析patch方法
### patch方法（新老VNode节点比对）
patch将新老VNode节点进行比对，然后将根据两者的比较结果进行最小单位地修改视图，而不是将整个视图根据新的VNode重绘。**patch的核心在于diff算法，这套算法可以高效地比较virtual DOM的变更，得出变化以修改视图。**

diff算法：通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，时间复杂度只有O(n)，是一种相当高效的算法。同层级只做三件事：增删改。

具体规则是：new VNode不存在就删；old VNode不存在就增；都存在就比较类型，类型不同直接替换、类型相同执行更新；

![img](https://i.loli.net/2017/08/27/59a2419a3c617.png)

这两张图代表旧的VNode与新VNode进行patch的过程，他们只是在同层级的VNode之间进行比较得到变化（图中相同颜色的方块代表互相进行比较的VNode节点），然后修改变化的视图，所以十分高效。
```js
  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }

    let isInitialPatch = false
    const insertedVnodeQueue = []

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else {
      const isRealElement = isDef(oldVnode.nodeType)
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR)
            hydrating = true
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode)
        }

        // replacing existing element
        const oldElm = oldVnode.elm
        const parentElm = nodeOps.parentNode(oldElm)

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        )

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          let ancestor = vnode.parent
          const patchable = isPatchable(vnode)
          while (ancestor) {
            for (let i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor)
            }
            ancestor.elm = vnode.elm
            if (patchable) {
              for (let i = 0; i < cbs.create.length; ++i) {
                cbs.create[i](emptyNode, ancestor)
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              const insert = ancestor.data.hook.insert
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (let i = 1; i < insert.fns.length; i++) {
                  insert.fns[i]()
                }
              }
            } else {
              registerRef(ancestor)
            }
            ancestor = ancestor.parent
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0)
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode)
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
    return vnode.elm
  }
```
## 二、Vue编译器Compile