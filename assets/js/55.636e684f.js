(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{255:function(t,a,_){"use strict";_.r(a);var v=_(0),e=Object(v.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"http2-0、http3-0、https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http2-0、http3-0、https"}},[t._v("#")]),t._v(" http2.0、http3.0、https")]),t._v(" "),_("h2",{attrs:{id:"一、http2-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、http2-0"}},[t._v("#")]),t._v(" 一、http2.0")]),t._v(" "),_("h3",{attrs:{id:"_1、概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、概念"}},[t._v("#")]),t._v(" 1、概念")]),t._v(" "),_("p",[t._v("简单来说，HTTP/2（超文本传输协议第2版，最初命名为HTTP2.0），是HTTP协议的第二个主要版本。HTTP/2是HTTP协议自1999年HTTP1.1发布后的首个更新，主要基于SPDY协议。\nHTTP2.0的特点是：在不改动HTTP语义、方法、状态码、URI及首部字段的情况下，大幅度提高了web性能。")]),t._v(" "),_("h3",{attrs:{id:"_2、什么是spdy协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、什么是spdy协议"}},[t._v("#")]),t._v(" 2、什么是SPDY协议")]),t._v(" "),_("p",[t._v("刚刚对HTTP2.0的介绍中引出了一个名词 —— SPDY协议，这又是什么呢？")]),t._v(" "),_("p",[t._v("SPDY是Speedy的昵音，意为“更快”。它是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。")]),t._v(" "),_("h3",{attrs:{id:"_3、http1-x的缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、http1-x的缺点"}},[t._v("#")]),t._v(" 3、HTTP1.x的缺点")]),t._v(" "),_("p",[t._v("任何事物的更新都是为了弥补或修复上个版本的某些问题，那么我们来看看HTTP1.x都有哪些缺点以至于我们要使用HTTP2.0。")]),t._v(" "),_("p",[t._v("HTTP1.x有以下几个主要缺点：")]),t._v(" "),_("ul",[_("li",[t._v("HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。")]),t._v(" "),_("li",[t._v("单向请求，只能由客户端发起。")]),t._v(" "),_("li",[t._v("请求报文与响应报文首部信息冗余量大。")]),t._v(" "),_("li",[t._v("数据未压缩，导致数据的传输量大。")])]),t._v(" "),_("p",[t._v("我们可以通过一个链接来对比一下HTTP2.0到底比HTTP1.x快了多少。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://pic4.zhimg.com/v2-4941fe9fd2f9eadcdc47932598c420e3_b.webp",alt:"image"}})]),t._v(" "),_("h3",{attrs:{id:"_4、http2-0的优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、http2-0的优点"}},[t._v("#")]),t._v(" 4、HTTP2.0的优点")]),t._v(" "),_("p",[t._v("HTTP/2 相比于 HTTP/1，可以说是大幅度提高了网页的性能。")]),t._v(" "),_("p",[t._v("在 HTTP/1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。")]),t._v(" "),_("p",[t._v("在 HTTP/2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也间接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。")])]),t._v(" "),_("li",[_("p",[t._v("多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。")])]),t._v(" "),_("li",[_("p",[t._v("header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。")])]),t._v(" "),_("li",[_("p",[t._v("服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。")])])]),t._v(" "),_("h4",{attrs:{id:"（1）二进制传输"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#（1）二进制传输"}},[t._v("#")]),t._v(" （1）二进制传输")]),t._v(" "),_("p",[t._v("HTTP2.0中所有加强性能的核心是二进制传输，在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。\n在HTTP2.0中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。\n"),_("img",{attrs:{src:"https://image-static.segmentfault.com/255/492/2554926774-5b8e41d288514_articlex",alt:"image"}})]),t._v(" "),_("p",[t._v("为了保证HTTP不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。")]),t._v(" "),_("h4",{attrs:{id:"（2）多路复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#（2）多路复用"}},[t._v("#")]),t._v(" （2）多路复用")]),t._v(" "),_("p",[t._v("在HTTP1.0中，我们经常会使用到雪碧图、使用多个域名等方式来进行优化，都是因为浏览器限制了同一个域名下的请求数量，当页面需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求时，资源需要等待其他资源请求完成后才能继续发送。\nHTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。\n帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。\n所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://image-static.segmentfault.com/145/296/1452964433-5b8e41d284282_articlex",alt:"image"}})]),t._v(" "),_("p",[t._v("HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。\n多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。")]),t._v(" "),_("p",[t._v("HTTP2中同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的\n延时和内存消耗。单个连接上可以并行交错的请求和响应，之间互不干扰。")]),t._v(" "),_("h4",{attrs:{id:"（3）header压缩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#（3）header压缩"}},[t._v("#")]),t._v(" （3）Header压缩")]),t._v(" "),_("p",[t._v("在HTTP1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。\n在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。")]),t._v(" "),_("h4",{attrs:{id:"（4）服务器push"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#（4）服务器push"}},[t._v("#")]),t._v(" （4）服务器Push")]),t._v(" "),_("p",[t._v("在HTTP2.0中，服务端可以在客户端某个请求后，主动推送其他资源。\n可以想象一下，某些资源客户端是一定会请求的，这时就可以采取服务端push的技术，提前给客户端推送必要的资源，就可以相对减少一点延迟时间。在浏览器兼容的情况下也可以使用prefetch。")]),t._v(" "),_("h4",{attrs:{id:"（5）更安全"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#（5）更安全"}},[t._v("#")]),t._v(" （5）更安全")]),t._v(" "),_("p",[t._v("HTTP2.0使用了tls的拓展ALPN做为协议升级，除此之外，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。")]),t._v(" "),_("h2",{attrs:{id:"二、http3-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、http3-0"}},[t._v("#")]),t._v(" 二、http3.0")]),t._v(" "),_("p",[t._v("HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。因为在出现丢包的情况下，整个TCP都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1来说，可以开启多个TCP连接\n，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输\n数据。")]),t._v(" "),_("p",[t._v("那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务\n了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。")]),t._v(" "),_("p",[t._v("基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上，当然 HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC，接下来我们就来学习关于这个协议的内容。")]),t._v(" "),_("p",[t._v("QUIC\n之前我们学习过 UDP 协议的内容，知道这个协议虽然效率很高，但是并不是那么的可靠。QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。这里我们就挑选几个重要的功能学习下这个协议的内容。")]),t._v(" "),_("h3",{attrs:{id:"多路复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[t._v("#")]),t._v(" 多路复用")]),t._v(" "),_("p",[t._v("虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。")]),t._v(" "),_("p",[t._v("并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。")]),t._v(" "),_("h3",{attrs:{id:"_0-rtt"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_0-rtt"}},[t._v("#")]),t._v(" 0-RTT")]),t._v(" "),_("p",[t._v("通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。")]),t._v(" "),_("h3",{attrs:{id:"纠错机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#纠错机制"}},[t._v("#")]),t._v(" 纠错机制")]),t._v(" "),_("p",[t._v("假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。")]),t._v(" "),_("p",[t._v("当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。")]),t._v(" "),_("h2",{attrs:{id:"三、https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、https"}},[t._v("#")]),t._v(" 三、https")]),t._v(" "),_("p",[t._v("HTTPS在传统的HTTP和TCP之间加了一层用于加密解密的SSL/TLS层（安全套接层Secure Sockets Layer/安全传输层Transport Layer Security）层。使用HTTPS必须要有一套自己的数字证书（包含公钥和私钥）。")]),t._v(" "),_("p",[t._v("HTTPS解决的问题")]),t._v(" "),_("ul",[_("li",[t._v("信息加密传输：第三方无法窃听；")]),t._v(" "),_("li",[t._v("校验机制：一旦被篡改，通信双方会立刻发现；")]),t._v(" "),_("li",[t._v("身份证书：防止身份被冒充。")])]),t._v(" "),_("p",[t._v("HTTPS加密过程：")]),t._v(" "),_("p",[t._v("1、客户端请求服务器获取证书公钥")]),t._v(" "),_("p",[t._v("2、客户端(SSL/TLS)解析证书（无效会弹出警告）")]),t._v(" "),_("p",[t._v("3、生成随机值")]),t._v(" "),_("p",[t._v("4、用公钥加密随机值生成密钥")]),t._v(" "),_("p",[t._v("5、客户端将秘钥发送给服务器")]),t._v(" "),_("p",[t._v("6、服务端用私钥解密秘钥得到随机值")]),t._v(" "),_("p",[t._v("7、将信息和随机值混合在一起进行对称加密")]),t._v(" "),_("p",[t._v("8、将加密的内容发送给客户端")]),t._v(" "),_("p",[t._v("9、客户端用秘钥解密信息")]),t._v(" "),_("p",[_("img",{attrs:{src:"/images/https.png",alt:"image"}})]),t._v(" "),_("p",[t._v("加密过程使用了对称加密和非对称加密。")]),t._v(" "),_("h3",{attrs:{id:"对称加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对称加密"}},[t._v("#")]),t._v(" 对称加密")]),t._v(" "),_("p",[t._v("客户端和服务端采用相同的密钥经行加密")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("    encrypt(明文，秘钥) = 密文\n    decrypt(密文，秘钥) = 明文\n")])])]),_("h3",{attrs:{id:"非对称加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密"}},[t._v("#")]),t._v(" 非对称加密")]),t._v(" "),_("p",[t._v("客户端通过公钥加密。服务端通过私钥解密.")]),t._v(" "),_("p",[t._v("非对称加密密使用一对非对称的密钥。一把叫做私有密钥，一把叫做公开密钥。私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。使用此加密方式，发送密文的一方使用公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听盗走。")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("    encrypt(明文，公钥) = 密文\n    decrypt(密文，私钥) = 明文\n")])])]),_("p",[t._v("由于非对称加密比对称加密要慢，所以我们就需要综合一下他们两者的优缺点，使他们共同使用，而这也是HTTPS采用的加密方式。")]),t._v(" "),_("p",[t._v("在交换密钥阶段使用非对称加密方式，之后建立通信交换报文阶段则使用对称加密。")]),t._v(" "),_("h3",{attrs:{id:"https-握手过程中，客户端如何验证证书的合法性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https-握手过程中，客户端如何验证证书的合法性"}},[t._v("#")]),t._v(" HTTPS 握手过程中，客户端如何验证证书的合法性")]),t._v(" "),_("ul",[_("li",[t._v("校验证书的颁发机构是否受客户端信任。")]),t._v(" "),_("li",[t._v("通过 CRL 或 OCSP 的方式校验证书是否被吊销。")]),t._v(" "),_("li",[t._v("对比系统时间，校验证书是否在有效期内。")]),t._v(" "),_("li",[t._v("通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致。")])])])}),[],!1,null,null,null);a.default=e.exports}}]);